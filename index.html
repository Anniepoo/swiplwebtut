<html>
<head>
<title>Tutorial -- Web Applications in SWI-Prolog</title>
<meta name="author" content="Anne Ogborn" />
<meta name="Copyright" content="Copyright (c) 2012 Anne Ogborn" />
<meta name="robots" content="all" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<p><a href="/swipltuts/">Home</a></p>
<h1>Creating Web Applications in SWI-Prolog</h1>
<p class='author'>Anne Ogborn</p><p class='author'>Revised 5/19/2013</p>

<p class='contents'>
<a href='#intro'>Introduction</a>
<a href='#1'>1 Setting Up Handlers</a>
<a href='#2'>2 Generating HTML</a>
<a href='#3'>3 Handling Parameters</a>
<a href='#4'>4 Sessions</a>
<a href='#5'>5 Dispatching Revisited</a>
<a href='#6'>6 Handlers Revisited</a>
<a href='#7'>7 Including Resources</a>
<a href='#8'>8 Authentication</a>
<a href='#9'>9 Running The Server</a>
<a href='#10'>10 Handling The Back End</a>
<a href='#11'>11 Debugging and Development Support</a>
<a href='#12'>12 Security</a></p>
<h2>Introduction</h2>
<a id='intro'></a>
<h3>Expected Results</h3>
<p>If you enter this course knowing SWI-Prolog well and have some experience with web development, you should be able to competently write production web applications afterwards. The learning curve is pleasantly short.</p>
<h3>Time</h3>
<p>3-6 hours if you do all the exercises. You can start writing 'real' code after finishing section 3 at minimum.</p>
<h3>Who This Course Is For</h3>
<p>This course is for anyone who knows SWI-Prolog reasonably well and wants to learn the web application framework bundled with SWI-Prolog. You will also need some fluency with web development basics like HTML, CSS, and HTTP.</p>
<p>Many programmers assume Prolog needs to be hosted with a 'normal' language. I'm not sure why. Certainly xpce wouldn't be suitable for many desktop gui systems. But those are becoming rare. Even the desktop systems I've written recently have been written as web servers that display the UI in the browser. This course is part of my response to this mentality.</p>
<h3>Why Prolog?</h3>
<p>Prolog is of course more associated with expert systems and torturing undergraduates than with production web applications. But I've found it an excellent system for building web applications as well.</p>
<p>Prolog programs are simply <em>smaller</em>. Prolog programs are often <em>one tenth</em> the size of equivalent Java programs. And smallness is a virtuous cycle. Smallness encourages well written code, and well written code is easier to maintain and refactor and remains small.</p>
<p>What makes Prolog systems small? Complex question, but we can identify various factors. With backtracking instead of control structures, Prolog eliminates the 90% of loops that are actually iterators. Backtracking often eliminates error handling. Partial binding and incomplete structures eliminate much data reformatting. And in general, there's just a lot more case based reasoning, which means a lot less ceremony associated with handling of edge conditions. And of course you can put a small reasoner in to figure out complex business logic like 'who'se allowed to edit this?'</p>
<p>The swipl web app framework is very friendly. You can edit running code and query make. (C-c C-m in the IDE editor) and keep going without disturbing state, and you can use the graphic debugger.</p>
<h3>Does Anybody Actually Use This?</h3>
<p>All these systems are in Prolog, using the web framework described in this tutorial.</p>
<p><img src="systemsusingprolog.png" title="The best way to be cool and ahead of the curve is by making sure large companies are using the technology before you try it" /></p>
<h3>Getting The Most From This Course</h3>
<p>This course is this web page and a series of example programs. </p>
<p>The examples are designed to take reasonable sized bites at a subject, progressively building knowledge. I introduce some subjects in one place, then revisit them later to deepen understanding.</p>
<p>The example programs are <em>not</em> reproduced here. I want you to actually <em>look at</em> and <em>fiddle with</em> the code. So hopefully you'll be encouraged to fiddle if you have to read the code locally. You can get the examples <a href="https://github.com/Anniepoo/swiplwebtut">https://github.com/Anniepoo/swiplwebtut</a></p>
<p>To get the most from this course, you'll need to</p>
<ul>
<li>Have a working <a href="http://www.swi-prolog.org">swi-Prolog</a> install </li>
<li>Get the example files from <a href="https://github.com/Anniepoo/swiplwebtut">github https://github.com/Anniepoo/swiplwebtut</a></li>
<li>Understand Prolog and SWI-Prolog's dialect before trying to build web apps</li>
<li>Read the text</li>
<li>Try each example program. Especially, look at the source of the resulting page. Experiment!</li>
<li>Do the exercises</li>
</ul>
<p>The example programs are labelled with the chapter and section number, so webserver1_2.pl is the code for chapter one section 2.</p>
<p>Different people will have different backgrounds and learning styles. Whatever works for you works.</p>
<p><a href='http://www.swi-prolog.org/howto/http/'>This page</a> in the swipl docs is useful as well</p>
<h3>Getting Stuck</h3>
<p>If you have questions and reasonable effort doesn't answer them, drop me email at aogborn (somechar) uh.edu. Please, if you're taking a beginning Prolog course, ask your instructor. Questions about family trees will be ignored. But if you're working on a web app, feel free.</p>
<p>Asking on ##Prolog on freenode.net is also a good way to get answers.</p>
<p>Finally, I well could be wrong. This material's not that well documented in spots, and I'm making these tutorials partly to teach myself. While the web app <em>feels</em> nice to handle, in practice I've had a frustrating number of wtf moments. I'm hoping this tutorial will help change that.</p>
<h4>Giving Back</h4>
<p>I was going to make some 'create a blog' fake project for the course, but realized that was a waste of good programming talent. Instead of having a useless project, I thought I'd invite  everyone who takes it contribute a piece to an opensource library. It's not a requirement, if you have a specific project of your own, feel free to do that. But if you're taking this course and want an under-a-day little project to cement your knowledge, maybe this is the thing for you.</p>
<p>I don't like big, monolithic libraries. It's frustrating to discover you have to accept a big memory hit and a bunch of painful setup to get one cool little bit. So I'm making a set of small, mostly independent tools.</p>
<p>I'm calling it <em>Weblog</em> a library that makes common web interaction patterns easier.</p>
<p>If you're up for it, head over to <a href="http://www.welie.com/patterns/index.php">Welie.com</a> and find yourself a pattern you like. It shouldn't be on the list below (those are done). </p>
<p>(This is the list - it's empty now).</p>
<h2>1 Setting Up Handlers</h2>
<p><a id='1'></a></p>
<h3>1_1 Hello Web</h3>
<p>(Like always, I'm assuming you're reading the code in the swipl IDE, so I'm not showing the code here).</p>
<p>Web apps in swipl can be run in various ways. The one we'll use to start is simply running as our own web server. I'm going to cover the larger issues later, so for now I'll give you a bit of voodoo code to get a basic server up and running</p>
<p>These lines include modules needed for our basic server</p>
<div class='precode'><pre><code>:- use_module(library(http/thread_httpd)).
:- use_module(library(http/http_dispatch)).
</code></pre></div>
<p>And this is our main server loop.</p>
<div class='precode'><pre><code>server(Port) :-
        http_server(http_dispatch, [port(Port)]).
</code></pre></div>
<p>Query <code>server(8000).</code>  to start the server on port 8000 and browse <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a></p>
<h4>Handlers</h4>
<p>Swipl web apps are defined as a collection of <em>handlers</em> . The first topic we'll cover is defining handlers. If you know Ruby on Rails these are like 'routes'.</p>
<p>We have a single handler that handles the root path /</p>
<div class='precode'><pre><code>:- http_handler(/, say_hi, []).
</code></pre></div>
<p>This declaration says 'handle the root of the tree by querying the goal say_hi.'</p>
<p>The first argument, /, is an atom that means 'the root of the URI'. So if we instead wanted our server to serve http://127.0.0.1:8000/twinkly/elf/weenblat.xls we'd say</p>
<div class='precode'><pre><code>:- http_handler('/twinkly/elf/weenblat.xls', say_hi, []).
</code></pre></div>
<p>The second argument will be called with <code>call(Arg, Request)</code>, where Request is the request info. This enables the handy trick of making similar handlers a single block of code with specialization.</p>
<p>The last argument is a set of options. The most interesting of these is <code>prefix</code>, which lets a single handler handle everything below the route as well. More about handler options in the section on serving asset files.</p>
<p>Now we're ready for the actual handler rule.</p>
<p>When the rule is called the current input stream has been redirected to read the HTTPRequest, and current output has been redirected out the socket, so all we need do is print the response. </p>
<p>We'll first write the required Content-type: header and then the body.</p>
<div class='precode'><pre><code>say_hi(_Request) :-
        format('Content-type: text/plain~n~n'),
        format('Hello World!~n').
</code></pre></div>
<p>Don't worry, this is NOT the usual way of writing content. But that's chapter 2!</p>
<div class='precode exercise'><pre><code>Exercise: Add two handlers to 1_1 that print two different hello messages. Add only two handler declarations and a single non declaration rule to the program.
</code></pre></div>
<h3>1_2 Abstract Paths</h3>
<p>Anyone who'se made a large web app will be worried by the way we've been encoding our HTTP paths. '/fluffybunny' is fine for a small website, but imagine maintaining a large system with all these absolute paths hard coded.</p>
<p>The solution is what swipl calls 'abstract paths', and the abstract path library <a href="http://www.swi-prolog.org/pldoc/doc/swi/library/http/http_path.pl">swipl docs</a>.</p>
<p>In 1_2 our handler declarations have changed. They now look like</p>
<div class='precode'><pre><code>:- http_handler(root(.), say_hi, []).

% And, just for clarity, define a second handler
% this one can by reached at http://127.0.0.1:8000/taco
:- http_handler(root(taco), say_taco, []).
</code></pre></div>
<p>The first is our old friend, the root handler, which serves http://127.0.0.1:8000/</p>
<p>Paths are from an abstract base. In our case, the only abstract base is root, which is defined as /. So / is root(.), /taco is root(taco), and <code>root('foo/bar')</code> is /foo/bar (note, not  <code>root(foo(bar))</code>).</p>
<p>So, you're thinking, other than syntactic change, so what?</p>
<p>On to</p>
<h3>1_3 Defining new abstract paths</h3>
<p>This code adds a hook predicate that defines a new abstract path. With it, we can now say files('zap.gif') to serve /f/zap.gif. If we move the files somewhere else we can just change one line.</p>
<p>Something to notice (obvious perhaps, but a source of much pain for me) is that the path to the root of <em>files</em> (second arg) is an absolute path specification, not root(.) </p>
<div class='precode'><pre><code>:- multifile http:location/3.
:- dynamic   http:location/3.

http:location(files, '/f', []).
</code></pre></div>
<p>Also notice that <code>location</code> is arity 3. It takes a list of options, the only valid option being <code>priority(+:integer)</code> which is used to disambiguate multiple handlers that handle the same URI. This is useful for defining a fallback handler for prefix of / to make a custom 404 page.</p>
<p>A warning of a confusing point. I was tryig to make these 'abstract paths' be abstract files paths for a long time when learning this stuff. Beware, the two have nothing to do with each other. To make things worse, later on we'll encounter them used together.</p>
<div class='precode exercise'><pre><code>Exercise: Add a handler that says 'sorry, not here' to 1_3 when you try something like http://127.0.0.1:8000/this/is/invalid
</code></pre></div>
<p>A final note. Remember that your server will some day probably be proxied to by apache, so your root path may be changed. This is an excellent reason to use abstract paths. If you have many abstract paths you can redefine http:prefix to change everything at once.</p>
<h2>2 Generating HTML</h2>
<p><a id='2'></a></p>
<p>So far we've served plain text. Lets serve HTML.</p>
<p>This is the largest chapter in the tutorial. It's oriented towards the built in swipl HTML generation support. I know that there are two camps when it comes to HTML generation.</p>
<p>The 'template' camp wants to edit HTML with normal HTML tools, and will live with awkward php/jsp/asp style <code>&lt;% .... %&gt;</code> escaping for dynamic generation.</p>
<p>The dynamic camp wants to dynamically generate web pages, and will live with 'funny looking' HTML to do that. </p>
<p>The built in generation is firmly in the 'dynamic' camp. If you pitch your tent in the template camp, look at <a href="http://www.cs.otago.ac.nz/staffpriv/ok/pwp.pl">PWP</a>. Swipl provides support for <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%283,%273.21%27,swi%28%27/doc/packages/http.html%27%29%29">integrating PWP</a>.</p>
<p>That said, you can indeed output a block of 'normal' HTML. Some strategies for doing so (skipping ahead a bit):</p>
<ul><li>Include bits of 'normal' HTML in an otherwise dynamic page by using the inclusion mechanism described under 'inclusion' in 2_6</li>
<li>Serve entire static pages (eg. a terms of service page) using the file serving mechanisms described in 6_1</li>
</ul>
<h3>2_1 Directly printing HTML</h3>
<p>We can serve HTML just by printing it.</p>
<div class='precode'><pre><code>say_hi(_Request) :-
        format('Content-type: text/html~n~n'),
        format('&lt;html&gt;&lt;head&gt;&lt;title&gt;Howdy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;A Simple Web Page&lt;/h2&gt;&lt;p&gt;With some text.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;~n').
</code></pre></div>
<p>Ouch!</p>
<p>Clearly we're not doing this for long. But it's nice to know you can just print if the handy helper stuff is fighting you.</p>
<h3>2_2  Using print_html</h3>
<p>This isn't any better, but is an important step in understanding.</p>
<p class='warning'><em>DON&apos;T</em> do this in your own code.</p>
<p><code>print_html</code> is a behind the scenes predicate that converts a list of HTML chunks into a string containing HTML.</p>
<div class='precode'><pre><code>say_hi(_Request) :-
        format('Content-type: text/html~n~n'),
    print_html(
    ['&lt;html&gt;',
     '&lt;head&gt;',
     '&lt;title&gt;',
     'Howdy',
     '&lt;/title&gt;',
     '&lt;/head&gt;',
     '&lt;body&gt;',
     '&lt;h2&gt;',
     'A Simple Web Page',
     '&lt;/h2&gt;',
     '&lt;p&gt;',
     'With some text.',
     '&lt;/p&gt;',
     '&lt;/body&gt;',
     '&lt;/html&gt;']).
</code></pre></div>
<p>Swipl has 3 representations for HTML. It can be a single atom, like in 2_1, or a list of tokens, like this, or a term form that we'll show next. Keeping track of which form you're working with can be one of the more confusing bits. So I'm introducing some terminology that Jan doesn't use in the swipl documentation.</p>
<ul>
<li><em>HTML atom</em> - an atom or string with HTML in it (the 2_1 representation)</li>
<li><em>Tokenized HTML</em> - the stuff above</li>
<li><em>Termerized HTML</em> - The stuff we'll show in 2_3</li>
</ul>
<div class='precode exercise'><pre><code>Exercise: Run 2_2 and look at the generated HTML.
</code></pre></div>
<h3>2_3 html//1 And Termerized HTML</h3>
<p><img src="comfy.png" style="float: left; margin-right: 12px" title="He's just read my DCG tutorial, that's why he looks like that"/></p>
<p>Finally, we see something that looks like reasonable HTML generation.</p>
<p>Web pages are inherently nested structures of boxes within boxes and areas on a page. While they have a strong structural similarity to their HTML representation,
they are not identical. A search box is not, conceptually, just a text field, but is a thing unto itself. Representing the page&apos;s structure and converting it to HTML sounds like a job for a language with good parsing and language transformation skills.</p>
<p>It sounds like a job for...</p>
<p>Paaa-Roooolloooooooooog....</p>
<div style="clear:both">&nbsp;</div>
<p>At any rate, it's a reasonable thing to do with DCG's, and that's what swipl does, in a sorta sideways way. Here's an example:</p>
<div class='precode'><pre><code>    phrase(
        html(<font color="#FF4444">html(
        [head(title('Howdy')),
         body([h1('A Simple Web Page'),
              p('With some text')])])</font>),
        TokenizedHtml,
        []),
</code></pre></div>
<p><code>phrase</code>'s first argument is a library DCG, <code>html//1</code>, whose argument (in red) is a DSL (domain specific language) which defines the HTML it recognizes. So, phrase/2 will unify in the above when <code>TokenizedHtml</code> is the tokenized HTML equivalent of the html defined by the first arg.</p>
<p>It is code in this DSL which is our 'termerized HTML'.</p>
<h3>2_4 Proving it's a real DSL</h3>
<p>Lets prove that it's a real DCG by abstracting out the generation into it's own nonterminal (See the file).</p>
<div class='precode'><pre><code>my_nonterm --&gt;
    html([html([head([title('Howdy')]),
               body([h1('A Simple Web Page'),
              p('With some text')])])]).

</code></pre></div>
<h3>2_5 reply_html_page</h3>
<p>Generating our own head and body tags is more ceremony than we really need. SWI-Prolog provides a nice wrapper that takes care of the boilerplate, and in the process handles a lot of other behind the scenes work.</p>
<div class='precode'><pre><code>say_hi(_Request) :-
    reply_html_page(
       [title('Howdy')],
       [h1('A Simple Web Page'),
        p('With some text')]).
</code></pre></div>
<p>We're down to a single API call that takes some termerized HTML to include in the head and the contents of the body, which is pretty close to zero 'non data' ink.</p>
<p>(If you're paniced and thinking 'oh, man, I don't control the head?', relax - you do, we'll get there when we cover the arity 3 version <code>reply_html_page/3</code> in section 2_7.</p>
<h3>2_6 Termerized HTML Syntax</h3>
<p>Now we're ready to look at the termerized HTML syntax. You'll definitely want to have 2_6 open in front of you as you read this.</p>
<p>The swipl docs for this are in <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%283,%273.17%27,swi%28%27/doc/packages/http.html%27%29%29">this location</a> (which I recommend bookmarking, as finding it is always exciting).</p>
<p>Termerized HTML uses an arity 1 or 2 term for each HTML tag.</p>
<p>The arg of arity 1 terms is the innerHTML. The args of arity 2 terms are attributes and innerHTML. Either one can be a list to allow multiple items.</p>
<div class='precode'><pre><code>say_hi(_Request) :-
    reply_html_page(
       [title('Howdy')],
       [
        h1('A Simple Web Page'),  % arity 1
        p(class=bodytext, 'With some text'),  % arity 2
        p([class=bodytext, style='font-size: 120%'], ['Bigger text', b('some bold')])
        ]).
</code></pre></div>
<p></p>
<p>The html//1 term takes a term or a list as it's sole argument, in the same format at the innerHTML argument of tag term</p>
<h4>Here's most of the forms you can apply:</h4>
<p>One form you <em>won't</em> see is a nested list.  <code>[p('a para'), [p('in a nested list')]]</code> is <em>not</em> valid termerized HTML. You've been warned.</p>
<h4>Inner HTML</h4>
<p>A simple headline with plain text inside it</p>
<div class='precode'><pre><code>    h1('A Simple Web Page'),
</code></pre></div>
<p>A bold paragraph</p>
<div class='precode'><pre><code>    p(b('some bold text'))
</code></pre></div>
<p>If it's a list, the items are converted individually and concatenated.</p>
<p>A div block with two paragraphs</p>
<div class='precode'><pre><code>div([p('a para'), p('another para')])
</code></pre></div>
<h4>Entities</h4>
<p>entity escaping happens</p>
<div class='precode'><pre><code>'&lt;b&gt;this wont be bold&lt;/b&gt;',
</code></pre></div>
<p>appears literally, not in bold.</p>
<p>If you need an entity you can name one</p>
<div class='precode'><pre><code>&amp;(copy)
</code></pre></div>
<p>gives a copyright symbol</p>
<div class='precode'><pre><code>p(['Copyright ', &amp;(copy), ' 2012, Anne Ogborn'])
</code></pre></div>
<h4>String Help</h4>
<p>There's much help to perform string operations. You can get <code>format</code> style formatting</p>
<div class='precode'><pre><code>p('these ~d things, faith, hope, and love. But the greatest of them is ~w'-[3,love])
</code></pre></div>
<p>Concatenation usually isn't needed, but is +</p>
<div class='precode'><pre><code>p('two strings'+'two strings')
</code></pre></div>
<p>would usually be expressed</p>
<div class='precode'><pre><code>p(['two strings', 'two strings')
</code></pre></div>
<p>Though the first doesn't leave a space between them</p>
<h4>Attributes</h4>
<p>This paragraph has a style and tooltip text.</p>
<div class='precode'><pre><code>p([style='font-size: 36pt', title='tooltip text'], 'With some text'),
</code></pre></div>
<p>If there's a single attribute the list can be omitted</p>
<div class='precode'><pre><code>p(class=foo, 'some text')
</code></pre></div>
<p>Notice that swipl will put the quotes around foo in the HTML. As always in Prolog you have to quote atoms with iffy chars in them, like the src and alt attributes below.</p>
<div class='precode'><pre><code>img([src='obama.png', class=pres, height=128, width=128, alt='Barack Hussain Obama'], [])
</code></pre></div>
<p>Attributes have an even more extensive set of helper operators.
Attributes can be specified by K=V pairs like <code>class=foo</code> or by K(V) terms like <code>class(foo)</code>. The latter form is useful for avoiding operator priority worries</p>
<p>Concatenate like this:</p>
<div class='precode'><pre><code>class=alert+AlertLevel
</code></pre></div>
<p>Format strings (like <code>format/2</code> go like this:</p>
<div class='precode'><pre><code>alt='Image of ~w'-[Subject]
</code></pre></div>
<p>+List produces a query string with proper urlencoding</p>
<div class='precode'><pre><code>href='mep.php?'+[name=Name, email=Email, sex=Sex]
</code></pre></div>
<p>This urlencodes an arbitrary atom or string</p>
<div class='precode'><pre><code>href='http://example.com/foo.php?msg='+encode(MyMessage)
</code></pre></div>
<p>Later we'll cover another way of specifying a handler, by ID. This syntax creates a URL from a location ID.</p>
<div class='precode'><pre><code>href=location_by_id(ID)  % treated later
</code></pre></div>
<p>A list not interpretable as right side of operator is joined with spaces. This is useful for multiple class lists.</p>
<div class='precode'><pre><code>class=[emphasize, left, question]
</code></pre></div>
<p>becomes</p>
<div class='precode'><pre><code>class="emphasize left question"
</code></pre></div>
<p>This section's certainly long, but it's the core of the tutorial. Still, lets break and do a few exercises to absorb what we've learned.</p>
<div class='precode exercise'><pre><code>Exercise: Build your own example of each element in this section
Exercise: Convert a simple web page (or part of one) into termerized HTML.
</code></pre></div>
<h4>Inclusion</h4>
<p>Inclusion is swipl's mechanism for encapsulating pieces of HTML generation code. Encapsulation is signaled by <code>\</code>.</p>
<p>Inclusion is simultaneously one of the neatest features of swipl web, and one of the greatest sources of frustrating bugs.</p>
<p>The secrets to avoid driving yourself insane with inclusion are, first, understand whether you're in termerized HTML or tokenized HTML space. Second, be aware you aren't in prolog, and need to follow the DSL's, not Prolog's, module rules.</p>
<p>Included lists are treated as literal, tokenized HTML to be included. So, you can include a block of HTML set up with a normal editor</p>
<div class='precode'><pre><code>    \['&lt;i&gt;in italic&lt;/i&gt;', '&lt;b&gt;now we have bold&lt;/b&gt;'],
</code></pre></div>
<p class='warning'>(If you do this you can't depend on <code>html//1</code> always producing valid HTML.)</p>
<p>More powerful, if the argument of \ is a term, it will be treated as a DCG, and expanded to tokenized HTML. This means you can create structured, reusable components of web pages, and pays off many times the slight awkwardness of 'funny looking html'.</p>
<p>The line </p>
<div class='precode'><pre><code>    \some_included_stuff,
</code></pre></div>
<p>Calls the DCG </p>
<div class='precode'><pre><code>some_included_stuff --&gt;
    html([p('Some included stuff')]).
</code></pre></div>
<p>Of course you can pass semantic arguments</p>
<div class='precode'><pre><code>\more_included_stuff('Whoop Whoop!'),
</code></pre></div>
<p>...</p>
<div class='precode'><pre><code>more_included_stuff(X) --&gt;
    html([p(['More included stuff: ', b(X)])]).
</code></pre></div>
<p>Notice you're back in tokenized HTML space (and in Prolog). You need <code>html//1</code> here.</p>
<p>You only need <code>html//1</code> when it's time to make literal HTML. Nothing wrong with</p>
<div class='precode'><pre><code>included_stuff(X) --&gt;
    another_inclusion(X),
    and_a_third_inclusion(X).
</code></pre></div>
<p>A useful way of thinking about inclusion is that \ is an escape that says, in effect 'enter tokenized HTML world'. \</p>
<p class='warning'>And, a caution. The list brackets for including a literal are not optional! <code>\['I end up in the emitted html']</code> and <code>\term</code> are completely different. The first puts <i>I end up in the emitted html</i> in the html. The second treats term as an inclusion.</p>
<h4>Inclusion And Modules</h4>
<p><img src="comfymodule-01.png" style="float: left; margin-right: 12px" title="His coffee's gone cold" /></p>
<p>If your inclusion is in another module, there's a syntax for finding it. Remember, you're <em>not in Prolog</em>, but <em>in the DSL</em>, so you have to explicitly specify the module. Further, there's an issue with the operator precedence, so the parens are necessary</p>
<div class='precode' style='float:left'><pre><code>\(othermodule:inclusion(X))
</code></pre></div>
<p>&nbsp;</p>
<p>If you make code that passes termerized html around, and then attempts to call semantic arguments within it, you may need <code>meta_predicate/1</code> to end up in the right module. Here be dragons. Fortunately there's an extension to meta_predicate that handles html. <code>html_meta</code> works like meta_predicate, but allows html as well as the usual ?, +, -, etc.</p>
<div class='precode' style='float:left'><pre><code>:- html_meta  my_inclusion(+,html,?,?).

my_inclusion(A, B) -->
    html(p('I treat A as a number ~d'-[A]),
    html(p('i appear in the middle')),
    html(B),
    html(p('i appear at the end')).
    
</code></pre></div>
<p style='clear:left'>&nbsp;</p>
<p><code>my_inclusion</code> takes termerized HTML as it's two arguments. The html_meta declaration ensures that a call to my_inclusion from another module will have any inclusions in the second argument wrapped with the proper module. Additionally, the pceEmacs editor will properly syntax color the argument.</p>
<p>I would say, module issues are, along with inclusion, the great pain points in using the web framework.  Don't go past this point without understanding the module system, <code>meta_predicate</code>, <code>meta_html</code>, and how inclusion works.</p>
<h4>Start A Project</h4>
<p>At this point our exercises start building on each other. You may want to copy one of the examples to create a starting point.</p>
<div class='precode exercise'><pre><code>Exercise: Create a simple web page with a form that does a GET to gather a message. You needn't build anything to handle the form.

Exercise: Encapsulate the form in a separate DCG so it can be reused.

Exercise: Create a DCG motd//0 that shows the MOTD or other dynamic data as an inclusion. Add it to your page.

Exercise: create a DCG my_fancy_border//1 whose argument is termerized HTML representing what's inside the border. Make it surround the passed HTML with a div with some fancy border. (for now use a style= attribute in the div, since we haven't covered stylesheet inclusion). 
Use it to style the MOTD block. Also use it to style the web form.

Exercise: Perform these refactorings: 
Add a module declaration to your code. 
Create a second module, and move my_fancy_border into it. 
Move  motd//0 to a third module.
</code></pre></div>
<h3>2_7 Styling</h3>
<p>Until now our web pages have looked pretty last century. To boot, we get no help adding the common elements across all pages. Lets spiff things up.</p>
<p>Corporate wants every page to say 'The Simple Web Page Site' across the top of every page. It's a common requirement. Why should we repeat that for each page?</p>
<p><code>reply_html_page</code> has an arity 2 and an arity 3 form. The arity 3 version saves us</p>
<div class='precode'><pre><code>say_hi(Request) :-
    reply_html_page(
        tut_style,   % define the style of the page
       [title('Howdy')],
        [\page_content(Request)]).
</code></pre></div>
<p>this declares to swipl's innerds that it should apply 'tut_style' to this page.</p>
<p>To define 'tut_style, we need to define a hook</p>
<div class='precode'><pre><code>:- multifile
        user:body//2.

% Body will be included
user:body(tut_style, Body) --&gt;
        html(body([ div(id(top), h1('The Simple Web Page Site')),
                    div(id(content), Body)
                  ])).
</code></pre></div>
<p>Observation here - what's coming in is <em>tokenized</em> HTML.</p>
<p>You can do the same thing with the head. Add a hook predicate for user:head. This is a possible, but rarely the best, method of including Javascript and CSS. More often, it's a great way to get things like the title and keywords set up.</p>
<p>Of course you can have more than one style. At my employer we use one style for content to be viewed on the web and one style for content to be viewed in the virtual world.</p>
<div class='precode exercise'><pre><code>Exercise: Add a header and footer to your web page from the exercises in 2_6 using body styling. 
</code></pre></div>
<h3>2_8 Mailman</h3>
<p><a href='http://www.swi-prolog.org/pldoc/doc_for?object=section%284,%273.17.2%27,swi%28%27/doc/packages/http.html%27%29%29'>Mailman</a> is a facility for creating HTML 
that ultimately ends up somewhere besides where you generated it</p>
<p>It has nothing to do with email</p>
<p>Sometimes it's a lot easier to compute content in a place other than where it needs to be included in the html.</p>
<p>Suppose we have a page with a top navigation area that gets dynamicly generated. Being organized, we abstract the nav bar into a DCG.</p>
<p>Early version - not like the example file</p>
<div class='precode'><pre><code>
page_content(_Request) -->
    html(
       [
        h1('Demonstrating Mailman'),
        div(\nav_bar),
        p('The body goes here')
       ]).
       
nav_bar -->
    {
        findall(Name, nav(Name, _), ButtonNames),
        maplist(as_top_nav, ButtonNames, TopButtons)
    },
    html(TopButtons).
</code></pre></div>
<p>The web designer notices that many of our pages get long, and wants to add a small type version of the navigation at the bottom.</p>
<p><img src="addfooter-01.png" title="No, I don't know what a web empowerer is. Neither do they, but they're funded through Q4 of next year."></p>
<p>We already have the list of buttons when we make the top menu. Can we avoid duplicating the work of making the list for the bottom?</p>
<p>Mailman allows us to generate tokenized HTML in one place and 'mail' it to another</p>
<p>File 2_8 sends the bottom buttons to the bottom with</p>
<div class='precode'><pre><code>\html_post(bottom_nav, BottomButtons)
</code></pre></div>
<p>and receives them with</p>
<p><code>div(\html_receive(bottom_nav))</code></p>
<div class='precode'><pre><code>
page_content(_Request) -->
    html([
        h1('Demonstrating Mailman'),
        div(\nav_bar),
        p('The body goes here'),
        div(\html_receive(bottom_nav))
       ]).

nav_bar -->
    {
    % we only need to find the ButtonNames once
        findall(Name, nav(Name, _), ButtonNames),
        maplist(as_top_nav, ButtonNames, TopButtons),
        maplist(as_bottom_nav, ButtonNames, BottomButtons)
    },
    html([\html_post(bottom_nav, BottomButtons) | TopButtons]).
</code></pre></div>
<p>A common reason to do this is a page element that in turn requires something in the head, say a
widget that depends on a css or js file. Another common reason is an element
(say a list of blog posts)
whose contents are accumulated during page generation, and a set of links to them near the top of the page.</p>
<p>Mailman is a useful tool. However, be aware, it doesn't know about modules and gets expanded elsewhere. You need to use the <code>\(module:name(args))</code> form for any inclusions you mail. (rumored fixed, 5/19/2013 AO)</p>
<div class='precode exercise'><pre><code>Exercise: Add an inclusion call to your page that takes an argument which is displayed in the page title.
</code></pre></div>
<h2>3 Handling Parameters</h2>
<p><a id='3'></a></p>
<p>By now you're probably itching to make something real. With parameters, we can start getting dynamic.</p>
<h3>3_1 <code>http_parameters</code></h3>
<img src="snake-handlers.jpg" title="Django dev. Bitten by an implicit join 30 seconds after this picture was taken. Has no problem handling parameters in SWI-Prolog." style="float:left; margin-right: 12px" />
<p>This section is about the pred http_parameters, documented at <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%283,%273.9%27,swi%28%27/doc/packages/http.html%27%29%29">this page</a>. </p>
<p>The documentation is actually quite good, so I'm going to refer you there for parameter handling, but tell you about some gotchas.</p>
<p>Gotcha #1: If a parameter is missing or invalid it doesn't fail, it throws an exception. 
This means you need a catch block around your code. In my own code I've written a http_parameters_quietly that wraps the exception and fails.</p>
<p>Gotcha #2: POST requests where the body has query string syntax aren't available without the form_data option.</p>
<p style="clear:left">&nbsp;</p>
<h3>3_2 Handling POST requests</h3>
<p>POST is often used to send large chunks of data not in search string format. Example 3_2 demonstrates directly reading the 
data POSTed by a web form.</p>
<p>Contrary to the statement at the top of the SWI-Prolog page, POST requests are not transparently handled. If you're handling a POST request 
you'll need to add <code>form_data</code> option to the <code>http_parameters/3</code> form. Additionally, the code apparently 
reads the POST data once, and can't backtrack.  3_2 demonstrates handling POST data.</p>
<p>A semi-useful tool for websites that shove many of the same parameters around is the <code>attribute_declarations</code> option. This allows you to define how to validate various parameters in one place.</p>
<p>Another useful gem is <code>http:request_expansion</code>. This lets you 'decorate' the request. For example, if you want some common data from a database attached to most requests, you could just have <code>request_expansion</code> decorate it.</p>
<p>Skipping ahead a bit, the session data is in the request structure and covers most uses of request_expansion.</p>
<p>Finally, you'll soon tire of passing Request around. You can get the current Request object with <code>http_current_request.</code></p>
<div class='precode exercise'>
Exercise: Create a landing page for the web form you made in 'inclusion and modules'.
</code></pre></div>
<h3>3_3 File Upload</h3>
<p>This example is taken in it's entirety from <a href="http://www.swi-prolog.org/howto/http/FileUpload.html">The swipl docs for uploading files</a></p>
<p>The documentation's pretty clear. </p>
<p>Since this is all Jan's code, not mine, you'll need to query run. and then browse localhost:8080</p>
<h2>4 Sessions</h2>
<p><a id='4'></a></p>
<h3>4_1 Basic Session Usage</h3>
<p>At this point you're probably fantasizing about all the stuff you can make in swipl web, but you know you're going to have to track sessions.</p>
<p>Implementing session control is insanely simple. More fun than <a href="http://xkcd.com/353/" target="_new">Python</a>.</p>
<div class='precode'><pre><code>:- use_module(library(http/http_session)).
</code></pre></div>
<p>Wait, no, cmon, it can't be that simple!</p>
<p>Yup. It is. You got sessions.</p>
<p>You know that lovable school/military/fascist youth camp tradition of giving people horrible nicknames? Ones they could never change? You didn't find it lovable? Me neither.
Lets build a site that gives people more affirming nicknames. Of course, once we pick their nickname, they're stuck with it as long as their session lasts. Right, Oh Blessed One?</p>
<p>Each request has a current session. That session has it's own knowledge base that can be controlled with <code>http_session_assert</code>, <code>http_session_retractall</code>, and the obvious analogous calls, and queried with <code>http_session_data/1</code>.  It's elegant and easy.</p>
<p>So, for our example, we'll check to see if we've given this person a nick. If we find one in their session data, great. </p>
<div class='precode'><pre><code>nick_name(Nick) :-
    http_session_data(nick_name(Nick)),!.
</code></pre></div>
<p>If not, we'll make one and assert into the session data</p>
<div class='precode'><pre><code>nick_name(Nick) :-
    nick_list(NickList),
    random_member(Nick, NickList),
    http_session_assert(nick_name(Nick)).

nick_list([
    'Gentle One',
    'Blessed Spirit',
    'Wise Soul',
    'Wise One',
    'Beloved Friend'
      ]).


Exercise: Run the server. Reload the page several times. 
Completely exit swipl and rerun the server. Confirm you can get a different name this way.

Exercise: Add another handler that lets you reset your nick without restarting the server. Use http_session_retractall to get rid of the old nick. Hint - you can just recurse into the handler to get the new one.
</code></pre></div>
<p>We won't cover it in this course, but you can control who gets a session. If you set the <code>http_set_session_options</code> create option to noauto you can  manually create sessions. If you want you can set the session lifetime. This can dramatically affect server memory if have a typical distribution of visitors, with many arriving at a single page and a few staying.</p>
<p>You can also restrict which parts of your site cause a session to be created. This can be very useful for, say, an informational site that doesn't need sessions for most visitors, but includes a small online store selling cafe press mugs and so on and needs sessions for the shopping cart.</p>
<h2>5 Dispatching Revisited</h2>
<p><a id='5'></a>
I promised we'd revisit dispatching. </p>
<h3>5_1 Prefixes and Path Rules</h3>
<p>A couple comments about the code. I repeat the <code>files</code> abstract path we defined in 1_3.</p>
<div class='precode'><pre><code>% from 1_3, if you've forgotten take a look
:- multifile http:location/3.
:- dynamic   http:location/3.

http:location(files, '/f', []).
</code></pre></div>
<p>Off topic, I use the fact that <code>http_handler/3</code> calls it's 2nd arg with one more arg (the Request), rather than with one arg, to cut down on code. </p>
<p>We often want to make a directory and serve everything in that directory as plain files. Or we want everything below a certain point to be handled by a different system.</p>
<p>We can define a handler that handles a path and everything below it by adding <code>prefix</code> to the option list <code>http_handler</code> takes as it's 3rd argument.</p>
<div class='precode'><pre><code>:- http_handler(root('bar/moo'), a_handler(barmoo), [prefix, priority(10)]).
</code></pre></div>
<p>Of course, between abstract path specification, prefix, handler declarations spread all over creation, and the way projects just tend to grow, we need some rules to resolve conflicts. Here they are. When both A and B potentially match:</p>
<ul>
<li>First, if handler A handles a <em>refinement</em> of B, (that is, A is more specific) then A wins</li>
<li>Second, if A is higher priority than B, A wins</li>
<li>Third, if A was declared after B, A wins (note that this might be exciting in a multifile situation. Try to stay outta this one.)</li>
</ul>
<p>To set priority use option <code>priority(n)</code>. <code>priority(0)</code> is default.</p>
<div class='precode exercise'><pre><code>Exercise: Run 5_1 and try each of these in a browser. Try to predict ahead of time what will be printed
http://127.0.0.1:8000/
http://127.0.0.1:8000/bar
http://127.0.0.1:8000/bar/
http://127.0.0.1:8000/bar/gorp
http://127.0.0.1:8000/bar/mep/fnord
http://127.0.0.1:8000/hoohaa
http://127.0.0.1:8000/numnums
http://127.0.0.1:8000/bar/moo/gleet
http://127.0.0.1:8000/bar/moo/waa
http://127.0.0.1:8000/hoops   (hoops isn't valid)
</code></pre></div>
<p>And another one</p>
<div class='precode exercise'><pre><code>Exercise: Provide yourself a nice error message instead of 404ing in response to an invalid path (hint, you need to complete the universe of paths).
Test your code to make sure you get the same answers as before for some of the paths listed in the previous exercise.
</code></pre></div>
<h3>5_2 Handler ID's</h3>
<p>There's no actual 5_2 file. </p>
<p>I think of this joke when I think of handler id's in swipl.</p>
<p><img src="http://imgs.xkcd.com/comics/standards.png" title="Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit." /></p>
<p>We can represent a handler in many different ways:</p>
<div class='precode'><pre><code>http://27.0.0.1:8080/f/bar
/f/bar
files(bar)
root('f/bar')
the f_bar_handler predicate
</code></pre></div>
<p>But ultimately none of these names <em>this</em> handler. All but the first name a <em>path</em>, concretely or abstractly. And that's something that can move around.
The last names the handling predicate. Often that's unique to a handler, but not always, as we've seen. So you can provide an option <code>id(login_page)</code> to the http_handler option list to name the handler itself. Once it has a name you can refer to it in various places, the most useful of which is for making links that don't break when you move things around:</p>
<div class='precode'><pre><code>a(href=location_by_id(login_page), 'Log in')
</code></pre></div>
<p>Now, that's great if whoever wrote the login_page handler gave it an ID. But if not, can you do the next best thing, and refer to the rule that handles it? Yup.</p>
<div class='precode'><pre><code>a(href=location_by_id(login_page_handler), 'Log in')
</code></pre></div>
<p>Of course it's probably in some other module. We can handle that (it's not obvious we can, we're in termerized HTML, not Prolog, remember)</p>
<div class='precode'><pre><code>a(href=location_by_id(login_module:login_page_handler), 'Log in')
</code></pre></div>
<p>If it's got args, you'll need to omit those (so it's less useful for our exercise)</p>
<p>And, a couple tools that occasionally are handy:</p>
<p>Get a URI for an ID</p>
<div class='precode'><pre><code>http_location_by_id(+ID, -Location)
</code></pre></div>
<p>And </p>
<div class='precode'><pre><code>http_link_to_id(+HandleID, +Parameters, -HREF)
</code></pre></div>
<p>And now for an exercise:</p>
<div class='precode exercise'><pre><code>Exercise: Load 1_3 and use the two API's above from the top level to establish the locations of some of the handlers.
Now add some ID's to 1_3's handlers. Using reply_html_page and html//1, make a site map that links to the other pages. Make the href's by location.
Now move 1_3's other pages to different URI's without changing your new handler code.
</code></pre></div>
<h2>6 Handlers Revisited</h2>
<p><a id='6'></a></p>
<h3>6_1 Serving Files</h3>
<img src="assets/swipl.png" style="float:left; margin-right: 12px" />
<p>I hope by this point you're getting excited about swipl web!.  </p>
<p>Maybe you're so excited you want to serve up the swipl owl!</p>
<p>No?</p>
<p>Well, you probably do have assets like this you want to serve up.</p>
<p>Fortunately, there's a canned handler that will serve files in a directory tree.</p>
<div class='precode'><pre><code>:- http_handler(files(.), http_reply_from_files('assets', []), [prefix]).
</code></pre></div>
<p>This line deserves some scrutiny.
First, note that we're finally seeing why I've been dragging around this files(.) location. Our path is the root of 'files', which maps to uri /f
Second, we're passing 'assets' to <code>http_reply_from_files</code>. That's a relative file path.
Swipl has an abstract file path system - you've seen it when you include modules with</p>
<div class='precode'><pre><code>:- use_module(library(http/html_write)).
</code></pre></div>
<p><code>library</code> is an abstract file location.</p>
<p>Lastly, note the <code>prefix</code>. So everything under the assets directory will be served. Wow, just like we're Apache or something! Maybe not. Can't make a living maintaining SWI-Prolog config files.</p>
<p>Run the server and browse http://127.0.0.1:8080/f/swipl.png
Congrats! The owl appears.</p>
<p>One bit of security here. You don't want to serve something outside the served space, so need to prevent J Random Hacker from asking for <code>http://mysite.com/f/../../../etc/passwd</code> or some such. So, it's wise to use <code>http_safe_file/2</code> to sanitize file names. http_reply_file does the sanitizing for you.</p>
<p>With finding files in various places and whatnot, interestingly, the swipl website's code to serve static assets is a good page long, much of it involved in displaying txt files by converting to html.</p>
<p>Hey, what happens if you ask for the directory?</p><p>There's a kumquat in there!</p>
<p>Gives a directory listing just like a real web server, even if it <em>is</em> in a language that's only used for AI. 
And, for the record, you can make an index.html page just like normal</em>.</p>
<p>The SWI-Prolog libraries define a few static file handlers - <code>css, js, and icon</code> are all
defined already. You probably want to have those same handlers. Easy! Just add your directory to the
file alias the library handler is already handling. If your css files are in <code>./files/css</code> under
your project directory, you can just do:</p>
<div class='precode'><pre><code>user:file_search_path(css, 'files/css').
</code></pre></div>
<p>Don't do this:</p>
<div class='precode'><pre><code>user:file_search_path(css, root('files/css')).
</code></pre></div>
<p>because root's a URI path alias, not a file alias</p>
<p>So, what happens if we ask for something that's not there?  Try http://127.0.0.1:8080/f/robot.png</p>
<p>Hmm... that's not so good. Nasty error message.</p>
<p>In a previous exercise we made a handler for everything else, but that responded with a page (a 200 response). Lets make a real 404.</p>
<h3>6_2 404 response</h3>
<p>When we can't do what we're asked, we fail. Can't serve a file at http://127.0.0.1:8080/f/robot.png, so we fail.</p>
<div class='precode'><pre><code>serve_files(Request) :-
     http_reply_from_files('assets', [], Request).
</code></pre></div>
<p>Instead of an ugly error lets do the right thing and serve a 404</p>
<div class='precode'><pre><code>serve_files(Request) :-
      http_404([], Request).
</code></pre></div>
<p>&nbsp;</p>
<div class='precode exercise'><pre><code>
Exercise: How would you make a 'site offline' function that the NOC staff could control?
</code></pre></div>
<p>And</p>
<div class='precode exercise'><pre><code>Exercise: Modify 6_2 to serve javascript, css, and image files from 3 separate directories.
</code></pre></div>
<h3>6_3 Redirect</h3>
<p>(no file)</p>
<p>You're probably wondering what happened to redirects. If you're used to the old 'not signedin, redirect' paradigm, you need it. But, actually, instead of a redirect, consider calling the handler of the page you're redirecting to. </p>
<p>If you need a real redirect, use <a href="http://www.swi-prolog.org/pldoc/doc_for?object=http_redirect/3"><code>http_redirect/3</code></a></p>
<h2>7 Including Resources</h2>
<p><a id='7'></a>
Well, we can serve files, now lets get them included in our web pages.</p>
<h3>7_1 Using mailman to include CSS</h3>
<p>One way to include resources is to use mailman to mail them into the head.</p>
<p>We'll receive the stylesheet link in the head. No need for fancy, we'll just put it in the material included in the head by <code>reply_html_page</code></p>
<div class='precode'><pre><code>a_handler(_Request) :-
    reply_html_page(
        [title('a page with style'),
         \html_receive(css)],
        [h1('A Page That Glitters'),
         \css('/f/specialstyle.css'),
         p('This para is green')]).
</code></pre></div>
<p>Now we need to make sure the css link gets sent. How about making an inclusion that does this for an arbitrary URL. Then we can include whatever bit of special CSS without much code.</p>
<div class='precode'><pre><code>css(URL) --&gt;
        html_post(css,
                  link([ type('text/css'),
                         rel('stylesheet'),
                         href(URL)
                       ])).
</code></pre></div>
<p>There is an implied html_receive(head) in reply_html_page. This is very useful for sending random things to the head.</p>
<p>A common situation is dealing with ugly hacks to get around IE borkedness. Here's a mess I needed for a Leaflet map:</p>
<div class='precode'><pre><code>
&lt;!--[if lte IE 8]&gt;
&lt;link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.5/leaflet.ie.css"&gt;
&lt;![endif]--&gt;
</code></pre></div>
 <p>The way to handle this is to use <code>\[...]</code> and mailman</p>
 <div class='precode'><pre><code>
     html([
          \html_requires(leaflet),
          \html_post(head,
            \if_ie('lte IE 8',
                      link([ rel(stylesheet),
                        href('http://cdn.leafletjs.com/leaflet-0.5/leaflet.ie.css')
                      ]))),
              div([ id(ID)
             ],
             [])]),
 </code></pre></div>
<h3>7_2 Including Resources With <code>html_resource</code></h3>
<p>This material is described in the <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%283,%273.20%27,swi%28%27/doc/packages/http.html%27%29%29">swipl doc for resources</a></p>
<p>Looking at 7_1, a few defects of the method come to mind</p>
<ul>
<li>There is nothing preventing the resource from being included twice</li>
<li>It's a bit of unneeded ceremony</li>
<li>If a resource needs another resource you have to remember that yourself</li>
</ul>
<p>Swipl to the rescue, sorta. As long as we're talking .js or .css files, you can do 'requires' type of thing. You declare 'resources', and then include them with <code>html_requires//1</code>. It's restricted to those two because it has to know how to expand them (eg for css it's to make a stylesheet link).</p>
<p>So, our page requires some special bit of css in specialstyle.css, which depends on the corporate standard 'gradstyle.css'. So lets enforce including gradstyle.css any time we include specialstyle.css.</p>
<div class='precode'><pre><code>:- html_resource(files('specialstyle.css'), [requires(files('gradstyle.css'))]).
</code></pre></div>
<p>The first arg is a standard path, as an URI or abstract path. The second is a <code>properties</code> list. The most useful is requires, which takes another resource path (abstract path here) or a list of such.</p>
<p>The other bit of magic we need is to declare that we need the resource. Since the declaration's a DCG we can just stick it in the termerized HTML.</p>
<div class='precode'><pre><code>a_handler(_Request) :-
    reply_html_page(
        [title('a page with style')],
        [h1('A Page That Glitters'),
         \html_requires(files('specialstyle.css')),
         p('This para is green')]).
</code></pre></div>
<p><code>reply_html_page</code> handles everything under the covers.</p>
<p>A useful tool for debugging resource dependencies is to turn on debug(html(script))
and monitor in the debug message window.</p>
<div class='precode exercise'><pre><code>Exercise: Use highcharts (http://www.highcharts.com/) to put a chart on a web page. Include all needed material with resources. 
</code></pre></div>
<h3>7_3 Some <code>head</code> Related Bits - Dynamic Javascript, AJAX, and XHTML</h3>
<p>No file for this section.</p>
<p>I want this tutorial to focus on understanding concepts. So I'm going to simply mention that there are <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%283,%273.18%27,swi%28%27/doc/packages/http.html%27%29%29">DCGs to create Javascript calls</a> and to support doing AJAX with <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%282,%275%27,swi%28%27/doc/packages/http.html%27%29%29">JSON handlers</a></p>
<p>Finally, something that's probably been driving you crazy, as it did me. By default swipl puts out non validating HTML (it doesn't even close P tags). To move into this century, call</p>
<div class='precode'><pre><code>    html_set_options([dialect(xhtml)])
</code></pre></div>
<p>before you start the server (you can set your DocType with that as well).</p>
<h2>8 Authentication</h2>
<p><a id='8'></a></p>
<p>authentication, cors, openid</p>
<p>This is a work in progresss. This chapter is still TODO.</p>
<p>But know that you can deal with cross site resources, basic authentication, and OpenID via SWI libraries.</p>
<h2>9 Running The Server</h2>
<p><a id='9'></a></p>
<h3>9_1 Server Top Level</h3>
<p>(no file)</p>
<p>Til now we've given you this block of voodoo code:</p>
<div class='precode'><pre><code>server(Port) :-
        http_server(http_dispatch, [port(Port)]).
</code></pre></div>
<p>Jan writes about 'three ways' to run the server.</p>
<p><code>inetd</code>, a unix daemon that handles the outer network interface, requires starting the prolog server separately for each invocation, and isn't really an option for serious work.</p>
<p>The XPCE based server receives XPCE events for incoming requests. It's not multithreaded, and it's only advantage is that debugging is slightly easier in a single threaded enviornment.</p>
<p>For serious use, the multi-threaded <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%284,%273.11.2%27,swi%28%27/doc/packages/http.html%27%29%29"><code>http_server</code></a> is the only reasonable choice.</p>
<div class='precode exercise'><pre><code>Exercise: Using the link above for http_server, answer the following questions:
</code></pre></div>
<ol>
<li>A client will be feeding your server data via long poll. What option will you have to adjust in <code>http_server</code>?</li>
<li>Your site for aerospace engineers processes data sets on users behalf by some powerful but very cpu intensive computation that can take up to 800MB of stack (but 'normal' sized trail and global memory) and run for hours. The average site user will run one of these a day. The output is a large raw video file that is then transcoded into a standard video format. The transcoding is shelled out, but can take a long time (minutes) to complete. Use <code>http_spawn</code> and <code>http_server</code> documentation to replace the ??? sections in the code below. (Note, there is no one right answer for this question.)</li>
</ol>
<div class='precode'><pre><code>
:- use_module(library(thread_pool)).

:- thread_pool_create(compute, ???,
                      [ local(??????), global(??????), trail(??????),
                        backlog(?)
                      ]).

:- thread_pool_create(video, ???,
                      [ local(???), global(????), trail(????),
                        backlog(???)
                      ]).

server(Port) :-
        http_server(http_dispatch, [port(Port), ?????]).

:- http_handler('/solve',     solve,     [spawn(compute)]).
:- http_handler('/video', convert_video, [spawn(video)]).
</code></pre></div>
<h3>9_2 Serving on port 80</h3>
<p>(no file)</p>
<p>The simplest way to get your server onto port 80 to serve to the world is to have Apache reverse proxy.  if your server is on port 8000, add this to site.conf</p>
<div class='precode'><pre><code>ProxyPass        /myserver/ http://localhost:8000/myserver/
ProxyPassReverse /myserver/ http://localhost:8000/myserver/
</code></pre></div>
<p>Note that this means absolute URLs in HTML content should be relative.</p>
<div class='precode exercise'><pre><code>Exercise: If you have access to a server, set 5_1 up to be served from port 80.
</code></pre></div>
<h2>10 Handling The Back End</h2>
<p><a id='10'></a></p>
<h3>10_1 SQL</h3>
<p>(no file)
A great quote from the swipl docs</p>
<div class='precode'><pre><code>The value of RDMS for Prolog is often over-estimated, as Prolog itself can manage substantial amounts of data. Nevertheless a Prolog/RDMS interface provides advantages if data is already provided in an RDMS, data must be shared with other applications, there are strong persistency requirements or there is too much data to fit in memory. 
</code></pre></div>
<p>Now, I think if we asked Jan, he'd say the last, 'persistency requirements' and 'too much data for memory' are better addressed with other solutions like <a href="http://cliopatria.swi-prolog.org/home">ClioPatria</a>.</p>
<p>But, if you need an SQL database, swipl has a reasonable <a href="http://www.swi-prolog.org/pldoc/package/odbc.html">ODBC Interface</a></p>
<div class='precode exercise'><pre><code>Exercise: Connect to whatever DB you have handy in your local environment and read out part of an existing table using swipl.
</code></pre></div>
<h3>10_2 Slightly Sick System</h3>
<p>(no file)</p>
<p>Are you in startup mode, or an experimental or 'fooling around' project? Want to save writing a back end? Here's a trick that's completely reasonable and saves half your dev time.</p>
<p>Simply use the prolog persistancy lib to snapshot your data. See <a href="http://www.swi-prolog.org/pldoc/doc/swi/library/persistency.pl"><code>persistance/1</code></a> </p>

<div class='precode exercise'><pre><code>
Exercise: Implement a toy application using the persistancy lib.
</code></pre></div>

<h3>10_3 NoSQL</h3>
<p>(no file)
How about using a database, but lowering the impedence bump between prolog's representation and the external DB?  Some options</p>
<p><a href="http://cliopatria.swi-prolog.org/home">ClioPatria</a>. Memory based RDF triple store. (persists as needed).</p>
<ul><li>Advantages: Very low impedence bump. Most prolog friendly - written to interface to swipl.</li>
<li>Disadvantages: Limited acceptance, you may be on the bleeding edge.</ul>
<p>A SPARQL based DB. Prolog has good facilities for <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%282,%279%27,swi%28%27/doc/packages/semweb.html%27%29%29">talking to SPARQL</a>.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> based DB. <a href="http://www.datomic.com/">Datomic</a> looks promising. Datalog is a subset of Prolog, so talking to it from prolog seems natural.</p>
<h2>11 Debugging and Development Support</h2>
<a id='11'></a>
<h3>11_1 Debugging Multi Threaded Code</h3>
<p>(no file)</p>
<div class='precode exercise'><pre><code>Exercise: run one of the examples.
query prolog_ide(thread_monitor).
</code></pre></div>
<p>Oooh, didn't that feel good?</p>
<h3>11_2 Reducing Abstract WTF Moments</h3>
<p>(no file)</p>
<h4>Resources</h4>
<p>Use ?- debug(html(script)). to see the requested and final set of resources needed </p>
<div class='precode exercise'><pre><code>Exercise: query ?- prolog_ide(debug_monitor).
Ooh and awe, then go read debug/1 and debug/3 docs
</code></pre></div>
<h4>Better Error Messages</h4>
<p>Loading <code>library(http/http_error.pl)</code>  causes uncaught exceptions in the server to generate a 500 error page with the error. (Remove this in production, it's never a good idea to give the hacker info about your system.) Most of the examples load this.</p>
<h4>Paths</h4>
<p>Abstract path locations can be confusing. You can check where they really resolve with <code>http_absolute_uri</code>.</p>
<div class='precode'><pre><code>?- http_absolute_uri(some('awful/path'), -URI)
</code></pre></div>
<p>File paths aren't much better</p>
<p>You can debug them by temporarily turning on the prolog flag</p>
<div class='precode'><pre><code>?-set_prolog_flag(verbose_file_search, true).
</code></pre></div>
<p>Any call to <code>absolute_file_name</code> (under the covers of anything that uses abstract paths) generates debug output.</p>
<p>If you just need to check one, use <code>file_search_path('some/path', Path)</code>. It's nondet, it'll give you all the possiblities.</p>
<p>But the best trick is that a relative path passed to <code>edit/1</code> takes you to the handler it resolves to, which is nifty.</p>
<div class='precode'><pre><code>?- edit('/wheres/this/go?kumquat=1').
</code></pre></div>
<h4>Where The Heck Am I?</h4>
<p>Another handy thing to put in the top of a puzzling handler is <a href="http://www.swi-prolog.org/pldoc/doc_for?object=section%283,%273.13%27,swi%28%27/doc/packages/http.html%27%29%29"><code>http_current_host</code></a>, whose last arg binds to the URI the server thinks it's serving.</p>
<h4>Ouch, that hurt on 4000</h4>
<p>Literate programming. Knuth says it's good, can't be bad, right? Hey, Java supports it. </p>
<p>Gotta pick a high port number. Steeped in tradition. Worked for a Chinese guy once who hired a feng-shui consultant to pick the number. Wish I could get that gig.</p>
<p>4000 is <em>not</em> your number. The PLDoc server runs there, and may be running in the background.</p>
<p>By default it's off and only responds to localhost. If you turn it on, change the default, and forget:</p>
<p>Phun 4 Hak3r Do0fs! Browse http://www.iamcoolmysitesinprolog.in:4000/ and read their PLDocs. That should make it easier to get in.</p>
<div class='precode'><pre><code>%% backup_pw(-UserName:atom, -Password:atom) is nondet
%   Hard coded admin password in case all else fails
backup_pw('admin', 'abc123').
</code></pre></div>
<h3>11_3 Logging</h3>
<p>Swipl includes a fairly bare bones logging package. Simply including </p>
<div class='precode'><pre><code>:- use_module(library(http/http_log)).
</code></pre></div>
<p>turns on logging.</p>
<p>Run 10_3 and look wherever you unzipped the examples. Youll have a new file, httpd.log
Open it, you'll see</p>
<div class='precode'><pre><code>/*Tue Aug 28 13:27:20 2012*/ request(2, 1346185640.163, [peer(ip(127,0,0,1)),method(get),request_uri('/favicon.ico'),path('/favicon.ico'),http_version(1-1),host('127.0.0.1'),port(8000),user_agent('Mozilla/5.0 (Windows NT 6.1; WOW64; rv:14.0) Gecko/20100101 Firefox/14.0.1'),dnt('1'),connection('keep-alive')]).
completed(2, 0.0, 428, 404, error(404,'/favicon.ico')).
</code></pre></div>
<p>Shucky darn!
Look at that error! No favicon.ico! The world will fall in!</p>
<p>At this moment your boss walks in and insists that you change the name of the log file.
Groan, don't you hate this sorta thing? finding it always takes way longer than it should.</p>
<p>Fortunately you remember it's in the settings, but of course have no idea what the setting name is. So you query </p>
<div class='precode'><pre><code>?- list_settings.
</code></pre></div>
<p>Ah, it's http:logfiles</p>
<div class='precode exercise'><pre><code>Exercise: change that puppy!
</code></pre></div>
<h4>Stopping The Server</h4>
<p>In theory </p>
<div class='precode'><pre><code>?- http_stop_server(8000, []).
</code></pre></div>
<p>will stop the server cleanly. At the moment on my system that's hanging.</p>
<p>Just exiting prolog always hangs. It doesn't kill the server demons.</p>
<h4>We're A Big Offical Site, We Have A NOC</h4>
<p>Look cool, make yourself an admin page that shows <a href="http://www.swi-prolog.org/pldoc/doc/home/vnc/prolog/src/plweb/stats.pl">server stats</a></p>
<h2>12 Security</h2>
<p><a id='12'></a>
Security Checklist</p>
<ul>
<li>are you vulnerable to prolog injection attacks? (easy to do with metaprogramming)</li>
<li>shell injection attacks? (sanitize args passed to shell). Prefer <code>process_create/3</code> over <code>shell/1</code>.  Safe argument handling and you can handle the output from the process much easier.</li>
<li>SQL injection?</li>
<li>PLDoc server on? (see Ouch that hurt on 4000)</li>
<li>Don't include <code>library(http/http_errors.pl)</code> to make hackers jobs harder</li>
</ul>
<h2>Thanks</h2>
<p>The author wishes to thank Jan Wielemaker, L.K. van der Meij, and confab for pointing out errors and improvements.</p>
<p>This tutorial was written using the free online markdown editor <a href="http://dillinger.io/">Dillinger</a>.</p>
<h2>Conclusion</h2>
<p>Thanks for taking this tutorial. If I can improve anything please email me at aogborn (hat) uh.edu.</p>
<p>If you make something beautiful, drop me a link.</p>
<p>Thanks,</p>
<p>Annie</p>
</body>
</html>